(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{353:function(e,t,r){"use strict";r.r(t);var _=r(43),n=Object(_.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"yjs-crdt-算法"}},[e._v("Yjs CRDT 算法")]),e._v(" "),r("h2",{attrs:{id:"简介"}},[e._v("简介")]),e._v(" "),r("p",[e._v("用于协作编辑的无冲突复制数据类型(CRDT，Conflict-free Replicated Data Types)是操作转换(OT，Operational Transformation)的另一种方法。它们之间有一个非常简单的区别，OT 尝试通过转换索引位置以确保一致性(所有客户端最终使用相同的内容)，而 CRDT 使用的数学模型通常不涉及索引的转换。比如链表。OT 是当前共享文本编辑的事实标准。OT 方法支持共享编辑，但没有一个真正的来源中心(中央服务器)，需要保持数量众多的记录文档，虽然在实践中是可行的。CRDT 更适合于分布式系统，它为文档能够与远程客户机同步提供了额外的保证，同样也不需要一个真实的中心来源。")]),e._v(" "),r("p",[e._v("Yjs 实现了"),r("a",{attrs:{href:"https://www.researchgate.net/publication/310212186_Near_Real-Time_Peer-to-Peer_Shared_Editing_on_Extensible_Data_Types",target:"_blank",rel:"noopener noreferrer"}},[e._v("这篇文章"),r("OutboundLink")],1),e._v("算法的一个修改版本。我们将会发表一篇论文来论述为什么这个方法在实践中如此有效。注意：由于操作组成了文档结构，所以我们现在更喜欢用"),r("code",[e._v("struct(结构)")]),e._v("这个词。")]),e._v(" "),r("p",[e._v("适合于共享文本编辑的 CRDTs 的缺点是它们只会增加容量。虽然有一些 CRDTs 不会变大，但却没有利于共享文本编辑的特性(比如保存)。Yjs 对原始算法进行了诸多改进，减少了文档容量不断增加问题。我们不能在确保结构的唯一顺序的同时对已删除的结构(tombstone，墓碑)进行垃圾回收。但是我们可以这样做：")]),e._v(" "),r("ol",[r("li",[e._v("将之前的结构合并到一个结构中，可以减少元信息的数量。")]),e._v(" "),r("li",[e._v("如果内容被删除了，我们可以从结构中删除它。")]),e._v(" "),r("li",[e._v("如果我们不再关心结构体的顺序(例如父结构被删除)，我们可以对墓碑进行垃圾回收。")])]),e._v(" "),r("p",[r("strong",[e._v("示例：")])]),e._v(" "),r("ol",[r("li",[e._v("如果用户按顺序插入元素，多个结构将会合并为单个结构。举例来说："),r("code",[e._v("array.insert(0, ['a']), array.insert(0, ['b']);")]),e._v("首先表示为两个结构"),r("code",[e._v("[{id: {client, clock: 0}, content: 'a'}")]),e._v("和"),r("code",[e._v("{id: {client, clock: 1}, content: 'b'}")]),e._v("接下来合并为一个结构"),r("code",[e._v("[{id: {client, clock: 0}, content: 'ab'}]")]),e._v("。")]),e._v(" "),r("li",[e._v("当结构中包含的内容(如"),r("code",[e._v("ItemString")]),e._v(")被删除了，那么它会被"),r("code",[e._v("ItemDeleted")]),e._v("所取代，这个结构中不包含任何内容。")]),e._v(" "),r("li",[e._v("在删除类型时，所有子元素将转换为"),r("code",[e._v("GC")]),e._v("结构。"),r("code",[e._v("GC")]),e._v("结果仅表示结构的存在和删除。如果有的结构体和其他结构体的 ID 相邻，那么它们就会和其他结构体合并。")])]),e._v(" "),r("p",[e._v("特别是在处理结构化内容(例如 ProseMirror 上的共享编辑)时，这些改进在"),r("a",{attrs:{href:"https://github.com/dmonad/crdt-benchmarks",target:"_blank",rel:"noopener noreferrer"}},[e._v("基准测试"),r("OutboundLink")],1),e._v("随机文档编辑时产生了非常好的结果。在实践中，它们的性能更棒，因为用户通常会按顺序编辑文本，从而产生易于合并的结构体。基准测试表明，即使在用户从右到左编辑文本的最坏情况下，Yjs 也能在处理大型文档时获得良好的性能。")]),e._v(" "),r("h2",{attrs:{id:"状态向量"}},[e._v("状态向量")]),e._v(" "),r("p",[e._v("当同步两个客户端时，Yjs 能够只交换差异。我们使用 lamport 时间戳来标识结构，并跟踪客户端创建它们的顺序。每个结构都拥有一个"),r("code",[e._v("struct.id = { client: number, clock: number}")]),e._v("，结构体的唯一标识。我们将每个客户端所期望的下一个"),r("code",[e._v("clock")]),e._v("定义为"),r("em",[e._v("状态向量")]),e._v("。这个数据结构类似于"),r("a",{attrs:{href:"https://en.wikipedia.org/wiki/Version_vector",target:"_blank",rel:"noopener noreferrer"}},[e._v("版本向量"),r("OutboundLink")],1),e._v("数据结构。但是我们只使用状态向量来描述本地文档的状态，因此我们可以计算远程客户端的缺失结构。我们不用它来追踪因果关系。")])])}),[],!1,null,null,null);t.default=n.exports}}]);